"Intro
hey so somebody just texted me that they
saw my account they wanted to know how I
set up cursor rules so I'm going to do a
quick video showing other people how you
can do it yourself one thing you should
know before we get started cursor rules
are not critical okay you can code just
fine without them so especially if
you're like a younger developer or
junior developer just getting into
things a lot of nontechnical people
becoming more technical because of tools
like cursor I would say just really
don't worry about this go use Lovable
Bolt even use cursor but don't worry
about rules you can do things just fine
without
it now all my rules are public so you
can go and grab them if you want but
they are specific to my project as well
so they might not help in your case
something to note when you do see a list
of like 20 rules like I have over here
and this is with all boiler plates
there's it's a bit like overwhelming
because it's like oh do I need this do I
need this and and so on really what I
would suggest is just build your own set
of rules for what is helpful for you bit
by bit so at the beginning I didn't have
this many rules it's not like I created
20 in one go i just like added bit by
bit and sort of that's how my rules grew
i used to have um a cursor rules like
one huge file with everything and then I
split it up into MDC files after that
A rule to create rules
the first rule I would recommend you
take from me though is the cursor rules
MDC it's pretty good and all it does is
it teaches cursor how to create cursor
rules and I'll show you how this works
in a second but yeah if you go to my
repo uh give it a star and if you uh
just copy this over it's pretty short
honestly haven't even read every word of
it so much of my rules is autogenerated
by other rules by AI and so on you can
see this is how I use Gmail in the
project and so on this is very specific
to me but every time I want to add a new
rule I'll be using this so let me show
you so what I'm going to do is I I have
Creating a rule
a rule for this already but I use a
package called S
swr and it fetches data from the server
and well you can see even here data
fetching MDC it has a rule like this
already but I'm actually going to create
a new rule just for the purpose of this
video and you can see throughout my
codebase I'm always going to be doing
something like this a very similar
pattern is always going to be like
loading content use SWL for my newer
rules I have something like this going
on um like use threads or I don't know
let's see use messages batch something
like this and so I'm always doing the
same thing over and over again and I
don't want to have to keep writing it
out so what I'm going to do is I'm going
to open up a chat over here and I'm
going to add this to the chat select
that code and add it to the chat and
then over here for um loading content I
also use this in the pattern and then
I'm going to tag at cursor rules oh
where did that go cursor rules and I'm
going to tell it um create a rule for
data fetching and loading i'm actually
going to do this in ask mode because the
cursor screws up a little bit with this
so I'm going to ask it to create the
rules for me um and then I'm going to
paste it in basically so um yeah that
looks fine to me let's run
it and you can see here's the rule
that's coming up which is good um I'm
just going to go it's called data
fetching.mmdc i think we've already got
that one right so let's call it um
data.mdc not really important and I've
just pasted it in and now I've got
another rule and so the thing to note is
at the top there's going to be this
information so we're going to want agent
requested here basically you can choose
the different options but I only want
this added when the agent requests it i
can obviously always tag it manually
like I just did with that other rule i'm
going to paste this in here uh the
globes this isn't actually important
because I want it to apply in a lot more
cases than just this and always apply
anyway this is going to be added anyway
so if I just go here and show you data
MDC you'll see this um meta data is
added to the head anyway um and that's
like what's happening here just cursor
isn't displaying it all anyway this is a
rule and now if I like actually want to
Using our created rule
go and use that rule let's say I do a
new file um let's create a file here
somewhere components uh new file uh
test.tsx now let's go and use our rules
so we called it
data.mdc uh load
data from threads it's just a test
loading two okay so let's see what
happens okay i don't know why it's not
doing it but let's say okay and you can
see that it's gone and done it uh it's
gone and done a decent job this is like
the rough pattern of what I use you can
see it's even gone and fixed um the lint
errors that it had over there the biome
errors and you know that is what I
wanted to happen we cater to the rule we
used it and a pattern like this I will
be using throughout my app um if I just
do the search again for use SWR you'll
find it in what is it 113 results in 48
files so instead of me having to type it
out every single time now I can
basically get a cursor to do it another
How to do it without rules
way to do this by the way without rules
you can just be like hey I want to do XY
Z do it similar to uh you know use
threads and now it would have done the
same thing as well without a rule just
giving it an example to work off of that
also works fine and you don't need a
special rule for that and here's another
Master index rule
rule I'm going to show you this is how I
created a real rule for myself very
recently basically cursor doesn't always
go and use all your rules for you so I
went and created a rule a master index
that basically lists out all my
different rules so somebody shared an
example on Twitter i basically said like
hey create um create a rule similar to
this i tagged my cursor rules.mmdc
follow this format and you can see it's
just a table of different rules and this
is what it came out as and I like gave
it a brief glance over you can see it's
tagging all my different MDCs and then I
just pasted it into here and so I'm
hopeful now when I said rule type always
I always want this to be available for
the AI i'm hopeful now that it will be
more likely to pick up rules
Summary
anyway I hope you enjoyed hope you
learned something from it remember keep
it simple just add one or two rules at
the beginning don't try and add 50
different rules a lot of these just get
added over time when I see my AI making
a mistake I just add it and then I can
easily tag the the correction the next
time I need it or tag it immediately if
I know I'm creating a cursor rule I'll
just tag cursor rules


Intro
hey there are five levels of cursor AI
code editor rules here you can click
cursor settings and open rules and here
you can see your code editor cursor
rules level this is my rules for code
editor i will show it later and you can
see project rules there are four
additional levels of cursor rules for
project rules you store not in your code
editor settings but in each project
separately in repositories and etc let
me show you how does it work let's start
IDE level of cursor rules
with code editor cursor rules here you
have big field you can fill with rules
cursor will add to any of your request
like when you write 1 to three here
actually it's not one two three is sent
to this model stop to this model but all
these instructions and then 1 to three
and that why you should write here your
highlevel habits maybe language you use
in chats maybe something like what
methods you like or don't like and it is
not related to exact wrapper but rule
for all your projects and good news
about this code editor level cursor
rules that it will be added to all of
your requests but bad news it's really
hard to share with someone for example
with your teammates I have created
article with all this data and you can
copy all my rules from this article to
your cursor code editor it is here my
website klmarkin.com articles cursor
code editor rules and here you can see
this code block you can just copy it
insert to your cursor and use it as your
code editor cursor rules you should be
really careful about these rules because
bad news about it all your requests will
spend LLM tokens to these rules and if
you spend more tokens
the quality of answer can be lower and
that why rules with less strings better
than rules with too much strings it
changed because right now we have bigger
context and etc but still try to be
short here even my rules it's a little
bit longer than I think it need to be
here you can see some habits some
information about readme files in
projects some GitHub CLI instructions
etc i will add link to this article
below the video on YouTube and you can
just click it and read all needed data
How to create project rules
now let's talk about project rules here
below you can see in code editor rules
section project rules and we can create
four different levels of rules here
there are few methods how to create rule
we can click this button add new rule
and name it test rule enter and this is
new project level rule by default it's
manual level but we have four different
one and we can write here I am working
this is it another way to create new
rule in chat you can write here
something like I would love to create a
rule about your answers when I in a good
mood or when I in a bad mood and here
you can click slash generate cursor rule
enter and now cursor code editor will
create this cursor rule for you you can
see new cursor rule here moodbased
response guidelines yeah and here is
some ideas from LLM what is rule about
you can change it blah blah blah and etc
and this rule will also be attached to
your project and the last idea how can
you create a rule it's just here in this
directory here in your project
repository directory you have directory
cursor then rules and here you can just
create new MDC file just from scratch
test to PC and if you will save data in
this MTC file the same format as others
this rule will work pretty the same
actually all these cursor settings
project rules rules add new rule button
do just create this document with
special format the format if we will
open something like that rule we can
open it in cursor again with this
special magic fields or we can write
click open with text editor and you will
see that all this additional magic with
these fields just these four lines
always apply true it means run type
always if we will change it to manual it
will be false and etc and just if you
will create text files with this MDC in
“Always” level of project rules
name and this data field it will work
pretty the same as your add new rule
button there are four levels of project
rules here let's start with always level
here in this my project you can this
rule index MDC rule index is just I
really like to create this rule first
and set rule type as always means that
this text will appear in chat every your
request it doesn't much matter you
mention this rule or not it works pretty
the same as code editor cursor rules but
related to exactly this project and here
you can see some overview what is it
project about some descriptions some
main places in project that I want
course to remember all the time when I
work on this project blah blah blah and
the difference between this run type
always project rule and our cursor code
editor cursor rules that this code
editor you cannot share easily with your
team and it's it is more related to your
habits across all the projects but this
file part of your repository you can
share it with your team you can create
them together these files that always
attached to the dialogue and rule pretty
the same try to be really short here
because like more tokens you use more
text you add to each of request it can
be related to low quality of responses
and actually pretty the same as this
rule type always there is a old method
how to create this kind of rules
attached to each of requests and related
to exact repository it's dot cursor
rules file let me show you in my GitHub
for example I have this repository repos
to text and in this repository it's
pretty old this day old yeah like few
months but here I use cursor rules file
you can open it and you can see pretty
the same yes some text appear in each
chat when you talk with cursor the llm
models it works pretty the same but
developers of cursor code editor already
marked these kind of files as legacy and
that's why maybe you shouldn't use it it
still works but it's legacy and maybe
for all of us better to switch to new
way to store cursor rules in this dot
cursor rules directories as rule type
always next level of cursor code editor
“Agent requested” level
rules is agent requested it means that
agent here can request this rule or not
and for agent requested you need to fill
this description with details when agent
should add this rule to chat and when
not let me show you for example we have
this image optimization cursor rule with
rule type agent requested let me show
you how it works for example here I can
ask please optimize image I will send
you in the next message enter and here
in chat you can see that agent remember
about this rule image optimization
without my additional instruction
related to it because I have this
description and agent all the time see
this description not full rule not all
these lines but only this description
and remember all these lines only if
agent decide it's related to our task
but be careful please if you will create
too Many rules agent requested type and
there are too many descriptions
different one cursor cannot remember
some rule even if you expect it happened
yeah you need to check that this
interface in your chart appear here rule
your name of the rule and some kind of
text and this if this block appear
cursor agent remember your rule if not
something happened and you need to add
it manually to your previous request for
example like that yeah and this is
important be careful with this agent
requested rules it's powerful feature
really interesting but for cursor it's
more easy to remember all related rules
next to the start of conversation not
after 5 minutes of your chatting usually
if you would love to remember some new
rules it's good idea to create new chat
and here ask to do something that
related to your new rules and etc let's
“Auto attached” level
talk about next rule type autoattached
this rule type allow us to create some
paths patterns that will allow chat to
attach this rule only if we work with
files match with these paths for example
here in this path content articles I
store my text of my articles let's open
this path our article about rules and
here you can see the markdown file and
because this file appear in the context
of our conversation this rule writing
style also attached to our conversation
i can turn it off if I want to but by
default when you walk in some path
related to this mask this rule will
appear here and how can you use it for
example here in my writing style I have
pretty long instruction how I write
articles how I want to sounds like how I
work with headers and etc etc but I
really want to add it to the context of
our conversation only if I walk for
articles for any of these files yeah but
not when I coding some Python code or
scripts and you can have a lot of
different pattern matches here and
remember some part of rules when you
walk on back end and other rules when
you work on front end and etc and last
“Manual” level
type of project rule it's manual let's
open this one for example you can see
rule type manual it means no automation
to add this rule here only you manually
can add this rule to the chart and it's
pretty long rule how to translate
article yeah when I finish for example
my cursor code editor rules article I
would love to do some translations to
top four languages for example to
Chinese and when I do this translation
usually I just open original article
remember this rule cursor rules article
translation and then please translate
this article to Chinese let's start with
our procedure and we go through this
rule article translation workflow and y
and you have a lot of manual cursor
rules as pieces of your knowledge that
not adding additionally to all your
requests but sometimes you need it for
example it can be some piece of
knowledge how to connect with some exact
database in the terminal and where you
store secrets to this database how to
create a connection and check data
scammer for example I have special rule
index now it's some rule how to post my
new URL to index now it's some special
index to have result quicker in bean and
some other search engines but when you
have this piece of knowledge you do not
need this all the time you can choose
agent requested with field description
or even manual and just manually add it
to the chart and after that cursor will
remember this content in your chat and
Workflow: how to work with your rules
can use it one guy from Canada last week
asked me if there are some rules for us
for people how to interact with each
other to create and handle cursor rules
and big projects what if it will be not
my personal website repo but some huge
repo with a lot of developers etc and as
director of R&D I have this kind of
experience and usually I guess one of
the best way how to work with that just
allow all your team to create any level
of rules just with understanding we need
to be pretty short and once a month
maybe once a couple of week do
refactoring unify some rules maybe
divide something to different files
maybe store some less data in always and
add some additional data to some exact
agent requested rule with a good
description maybe even switch from agent
requested to manual if you have too many
different rules and agent cannot handle
it etc i guess one of the best way here
is just contribution and refactoring
this is how it works for my projects
Outro
okay let's sum up all we talk about
please start with your code editor AI
rules here fill something you need from
your code editor all the time and it
will be your start just rules here maybe
five lines yeah then when you understand
that there are some rules related to
exact repo please create a new project
rule here by this button and set rule
type always and this text will appear in
all your charts but not in your cursor
there but exactly to this exact rapper
you open if you work for two three five
more rappers you need to store rapper
related cursor rules here then when you
realize there are too many lines here in
rule type always you need to remember
it's not a good way you need to have not
too many lines here then you start to
divide this index MDC file to more files
and choose for them different rule types
for some of them you can use agent
requested and hope agent will remember
it usually it works especially if you
have less than 10 different edit
requested files it works perfectly start
with that if you understand you need
some rules only in some special
directory in your project please create
autoattached rule with some matches
patterns and then if you have too many
agent requested rules and agent cannot
handle it you can reduce number of them
by switching some of them to manual and
mention this rule here manually but all
other will still be agent requested and
it will work better because you reduce
uh number of different rules for agent
this is it for cursor code editor rules
i'm Kuriel Markin founder and AI data
engineer thank you for watching please
subscribe ask questions in the comments
have a nice day

Introduction & what is a PRD
okay in this video I'm finally going to
share something that I've been planning
for a while and that is my custom Cloud
project for creating prds and what is a
PRD a product requirements document
product requirement document is a
document containing all requirements for
a certain product it is written to allow
people to understand what a product
should do and the way this works is a
cloud project that uses custom
instructions that uses multiple mCP
servers and also uses the latest CLA 3.7
thinking model I think this will be
incredibly useful for anyone that's
trying to build anything either with AI
or with regular old humans and just a
quick background on me I've been in tech
for over 10 years I was a Founder a
product manager a consultant I worked in
privacy I worked in accessibility I've
also worked closely with startups from
Guiding them from ideation to launch on
various products I've been helping
individuals and businesses integrate AI
into their workflow and right now I
really think I'm at the peak version of
my cloud project for creating prds and
I've been refining and working on this
project it keeps getting better once mCP
servers became a thing I added
sequential thinking Brave search to v
file system and fetch and then last week
Claude released 3.7 thinking I'm going
to show you my latest iteration my
latest custom instructions and what
you'll get at the end of this process is
a very well- written PRD a document that
you can share with your designers with
your engineers with other stakeholders
Background & experience with PRDs
in your company or with cursor with wior
any AI tool you're using to build
anything because this document aligns
everybody it gives all the context
needed to get get started so what will
you need access to Cloud projects you'll
need to have the following mCP servers
installed and I've done various
tutorials on all of them sequential
thinking Brave search tavil fetch file
system and this setup is great for
anyone who's trying to build with either
AI tools like cursor with wind surf chat
gbt and again even if you're building
anything with regular humans here's the
thing building anything especially with
AI revolves entirely around context but
I'm not going to sit here and tell you
you're going to be able to build
anything with AI there's a lot of hype
and getrich quick to all that I'm just
going to show you how I do it and give
you the tools so you'll be able to go on
and build things by yourself and the PRD
is a living document it's both
qualitative and quantitative and it
evolves as more insights become
available it clarifies what you're
building why you're building it who it's
for initial thoughts on technology and
platforms user stories pain points and
the overall solution what prds don't
usually contain are the how how we're
going to build a product it's more about
what and why and making sure that
everybody's aligned and understand those
MCP servers & Cloud 3.7 features
things before you go forward and write a
single line of code that comes later the
way I look at it is just like asking
clarifying questions you want to get to
the why you want to understand
everything so then you can get a more
holistic understanding of what you're
trying to build so then when you try and
go out and build something you're able
to do it in a systematic iterative
manner without going all over the place
oh I want to add this feature now that I
think about it I want to add this
feature that might work but is it
efficient is it scalable will it drive
AI or humans crazy yes yes so what I did
was take my experience as a product
manager broke it down into a cloud
project and if you follow my channel you
know I love Cloud projects and what I do
with Cloud projects is I build a
different Cloud project for every task
I'm doing so this is a PRD Creator which
I've made multiple versions of this is
my latest one PRD Creator 325 March 2025
I've iterated on it a lot it's gotten a
lot better with the mCP servers and with
Cloud 3.7 son it and the way this works
essentially is you just start talking to
Cloud you give it an idea you talk about
it about the product or the future you
want to build we're actually going to do
this with vibing with using Mac whisper
right now to just verbally dump
everything and it will make our process
even faster and I made a different video
on vibing or using AI dictation it's
going to be very useful here as well and
Custom instructions & project setup
what happens is basically you start
telling Claud what you want to build
Cloud will ask you clarifying questions
in a systematic manner to help you iron
out what you're trying to build and at
the end of it you'll come out with a PRD
and this PRD essentially acts as a
single source of the truth so that you
and your real life human team or your AI
companion will be able to look back at
this and understand what you're trying
to do remember what the context is
remember everything that needs to be
considered when building the next
feature or next line of code so just to
show you how this works we're going to
put together a PRD and what I'll give it
is my Chrome extension for creating a
YouTube playlist without paying for
YouTube premium so first of all we're in
the PRD Creator Cloud project here's the
custom instructions I give it a role and
identity I give it conversation ational
approach I give it a question framework
the type of questions to ask and every
question pretty much Builds on the
previous question based on the context
you give it and I have it start Broad
and filter down with specifics I give it
examples of how I want to ask questions
then I tell it how to use tools now this
is the one thing that I'm still
tinkering with with Cloud 3.7 is it
doesn't call the mCP servers all the
time even when I tell it explicitly to
do it in the custom instructions so I
give instructions on how to use them but
I do find that sometimes you have to
nudge it you have to say use sequential
think use Brave search use toil use
Live demonstration: Chrome extension PRD creation
whatever you have just to kind of remind
it now as you see here I have 69 mCP
tools available noise the ones I think
you should have are brave search file
system tely sequential thinking and
fetch I've done several videos on how to
install these mCP servers okay so now
let's just trigger Mac whisper I want to
create a Chrome extension that helps me
save videos via YouTube Vimeo Twitter
videos to a list inside my Google Chrome
or any Chromium browser so I don't have
multiple tabs open that take up memory
and I don't pay for YouTube premium so
the idea of this of this extension is to
save all these videos in a manner that I
could just click into it and watch it
like a playlist and I expect this to
work across various browsers I can log
in with my Google account and I plan on
building this with cursor okay so we
just did a verbal dump of what I want to
do here using Mac whisper so let's just
press go and see what happens and keep
in mind it's thinking now using Cloud
3.7 thinking then it will also use all
these mCP tools so let's see what
happens I thought for 4 seconds hi there
I'm excited to help you plan out your
Chrome extension for saving videos
across different platforms I'll ask you
a series of questions to understand your
vision better then I'll create a
comprehensive PRD that you can use as a
blueprint for development let's start
with a few fundamental questions about
your video saver extension so clarifying
questions Beyond YouTube Vimeo Twitter
are there any other video platforms you
like your extension to support what
specific information about each video
would you want to save how do you
envision the user adding videos to their
list for example would there be a button
that appears when watching a video or
right click context menu option or some
other method would you like the
extension to offer any organization
features like folders tags categories
for the save videos so again we're going
to use Mac Bri just to answer this I'm
just going to Rapid Fire 1 2 3 4 I think
for now we can just stick with YouTube
for a minimal viable product and then we
can move forward to Vimeo and Twitter
two I think we should save the URL the
title the thumbnail and the duration now
I don't want to pay for the YouTube API
or any apis right now if we don't have
to so I'd like you to look into a way of
doing this without signing up for API
access number three I Envision the user
right clicking the video and and hitting
a context menu button saying add to
playlist and for now I don't think we
need to deal with any folders tags or
categories for save videos this is a
great idea for a future feature so I
just dictated my answers back a lot
faster than typing and now let's just
press enter and see what happens okay so
we have more questions this gives me a
clear picture of what you're aiming for
with your video saver extension let me
ask a few more targeted questions to
further refine the concept so you know
what I'm just going to answer it as we
go I would like to open the original
YouTube page when the save video is
clicked next question eventually I'd
like the extension to sync my videos
across devices using my Google account
but for the first version we can do
local storage regarding the context menu
I'd like it to appear when clicking a
YouTube video either as a thumbnail or
in the video itself and only then would
it be able to be added to the watch list
to the playlist for specific UI
preferences for a proof of concept let's
just do a vertical list and I imagine it
having thumbnail the title the duration
and maybe also a numbered list so we
know what number on the list it is
regarding preferences on how the video
should be stored or ordered in that list
I think chronologically as added the
newest one first and as you see here
what it's essentially doing is asking me
all these questions that when I first my
idea I didn't didn't necessarily come to
my mind but if you plan all these things
out ahead of time you're going to have a
much better time when you go out and
build it instead of just thinking oh
wait I should add this okay so now it's
getting to technical okay I'm just go
ahead and answer these questions you can
pause the video and see what the
questions are I just don't want to take
too much of your time yes I'm very
comfortable with the extension using
content scripts if it's difficult to
obtain the video duration without the
API then we can skip it for this version
regarding the text stack I myself am not
AEL developer I will be building this
with the help of AI so I'm not sure the
best tech stack for building this so you
can do the research using Brave or t or
sequential thinking to figure out the
best framework for building this
regarding additional features I think
it's a good idea to have the ability to
remove a video from the playlist as well
as a way to Mark videos as watched
regarding visual design I just wanted to
be clean and modern looking I don't want
it to be too colorful I like dark mode
as you saw there I had to kind of push
it to use sequential thinking and brave
Reviewing the generated PRD document
search and that's the one thing with
Cloud 3.7 it doesn't always call mCP
servers as much as 3.5 did so sometimes
you have to nudge it but that's fine
first I need to analyze the requirements
for this Chrome extension parse YouTube
store videos Implement a context menu
support removing videos and making them
as a watch so it's already taking all
the information we've given it more
sequential thinking Brave SE sequential
thinking and of course it's using its
built-in Cloud 3.7 extended thinking now
let me consider the technical
architecture of this extension and
because it uses bra search it saw Chrome
now requires the newer manifest which
has different apis and security modules
compared to V2 okay thanks for the
additional information based on our
discussion and the technical analysis
I've just completed I now have a clear
picture of your Chrome extension let me
create a comprehensive PRD for your
YouTube video playlist saver I'll now
generate a PRD that outlines the
functionality architecture
implementation details of your extension
and what I had it do is save it
automatically to the file system as well
so we see it here writing files to file
system the PRD covers all aspects of
your extension including app overview an
objective target audience core features
technical stack data model UI design
principles development phases potential
challenges future expansion technical
implementation notes this approach
provides a good balance of Simplicity
and structure that will be suitable for
development with cursor and AI
assistance so now I just opened up my
PRD project name YouTube video saver
project description and Chrome extension
allows users to save YouTube videos to a
personal playlist without requiring
multiple open tabs or premium
subscription the extension enables users
to save videos while browsing YouTube
view their collection and clean
interface and manage their watching
status love it primary users YouTube
viewers who regularly save videos for
later viewing users who want to organize
their YouTube watching experience people
who want to reduce their browser tab
clutter users who don't have YouTube
premium but want playlist functionality
then user stories as a user I want to
save YouTube videos while browsing so I
can watch them later without keeping
multiple tabs open as a user I want to
quickly access my save videos in a
simple list format this is great core
functionality video saving playlist
viewing playlist management user
interface and each one has its design
principles its main views and its
acceptance criteria this is looking good
text stack recommendations then it does
a conceptual data model video object
structure Cool Storage schema data
operations way design principles talks
about the layout talks about the color
scheme security consideration
development phases and Milestones this
is big it pretty much breaks everything
down into steps and while this isn't a
technical breakdown of how to actually
GitHub resources & custom instructions
build this it breaks it down into
development phases milestones and
obviously you should iterate on this but
I think it comes out pretty good
potential challenges and solutions
future expansion possibilities I told it
about some features I wanted to do in
the future then it has technical
implementation notes and then it also
has links on how to get all these
documents it is so powerful so what
happens now is you could either iterate
and improve this and go back and forth
with Claud because I do think it's
important to iterate not just take the
first thing you get from it make sure it
covers everything you want to do you may
want to add different things you may
have different ideas it may have done
something wrong once you have this done
what you can do is you can take this and
put this into cursor for example what I
usually do I write a PRD then I open a
new cursor project I create a new
directory documentation and the first
thing I put in is this PRD whatever
platform you're using to build you now
have a document that covers everything
that you didn't think about right away
when you said I had this idea or I want
to build this way it helps you figure
everything out and maybe not everything
but it gets you 70% of the way there so
I will share my custom instructions and
I get help link below I'm going to share
two different versions I'm going to
share the one I've been using for the
last few months which I think is really
good and this newer version which I'm
still iterating on but I think it came
out pretty damn good I have to say that
the minute I started implementing this
with everything I built with AI and
really became systematic and iterated
and trying to think about all the edge
cases and the Technologies and features
I didn't think about and had AI helped
me plan this out I became much more
efficient and I was able to to ship or
just use my product a lot faster so I
Closing thoughts & invitation for feedback
think this is enough to start building
with AI if you have any feedback any
questions if you think I should change
it and you want to work on it and
iterate on it feel free write a comment
below I want you to be able to take this
and build good things with it so if you
learned something or you found this
video helpful do me a favor and like the
video if you haven't done so already
please subscribe to the channel it
really helps me grow thank you for
watching happy building and have a great
day



Task management in AI coding
[Music]
if you haven't been vi coding enough you
must have experienced problem where you
ask cursor to implement a small change
but just map up your whole project or
cursor is not aware of all the
dependencies in your codebase and
implement something that leads to loads
of errors This is a very common issue of
AI coding agent in general no matter
which platform you're using But there's
one technique that show promising
improvements that will make your cursor
make way less errors which is giving
your AI coding agent a task management
system It helps it to understand overall
implementation plan and also control the
amount of context goes into each step
when it is implementing specific tasks I
was able to build a fully functional
multiplayer online drawing game where
both players can draw image of given
work and we send the result to GBD4
where it look at image and give
evaluation and pick up the winner And
this whole game is actually imprinted by
cursor with just one shot without much
arrow which is absolutely insane That's
why today I want to show you what my
workflow is and how can you adopt it for
your own project And before you use any
of those tools I just introduced people
has been hacking together task
management workflow to improve
performance for a while At its core it
basically means you ask cursor to break
down your complex PRD into small tasks
and have a document where cursor can
have access to to track and maintain
what tasks are coming and what tasks
already been done And this is a quick
example from Elle The most basic
implementation is in your cursor project
Native Cursor way
you will create a cursor rule and it
looks something like this Basically rule
where you tell cursor to always refer to
task.md to keep track about what task
they already been done and what task
haven't And with this one we can just
create a task.md file and give a prompt
I want to build a x app help me breaking
down into small task of our core me
feature and add to task.md So cursor
will create a list of task here and
after cursor finish every single task it
will just come back and mar those task
as completed So it has a context of
overall implementation plan With this
method it already help a ton for
executing complex task with cursor But
tools like cloud taskmaster and boomeran
task from ruk code bring even more
sophisticated task management behavior
into the AI coding agents For example
for task master AI it is a command line
package that you can run in cursor
windsurf data where it utilize cloud 3.7
or more advanced model to look at PRD
you have and break that down into small
subtasks by running a simple command
line like taskmaster parse PRD And
what's really amazing about it is that
it will breaking down tasks in logical
order consider all the dependencies
between different tasks So you won't
have situation where cursor implements
something but require other dependencies
that hasn't been implemented yet It also
has useful command line like analyze
complexities to use perplexity and cloud
to analyze how complicated each task is
and if certain task complexity score is
very high it will allow you to expand on
those task further and by breaking down
those complex tasks into even smaller
bits The success rate of it delivering a
functional application just increase
dramatically And Roco's boomeran task
also something similar It gives AI
agents tools like new tasks to breaking
down a complex project into small bits
and keep track about progress Those
tools have completely changed my
workflow So I'm going to quickly take
you through what's my new best practice
vibe coding workflow with those new
tools But before we dive into that I
know many of you are trying to build AI
agents for business But there are many
pitfalls I saw people fell into at
delivering successful production agents
That's why I want to introduce you to
this research HubSpot did where they
interviewed tons of business and
startups who have been launching AI
agents for the past 12 months to
understand which AI agent use case
actually drove huge amount of business
value and ROI versus ones that sounds
fancy but actually very difficult to
deliver value and which signal customers
are deploying huge amount of budgets to
buy AI agent solution They include lots
of real world success stories and
articulate those learnings into
frameworks that you can use to build
your next agents from which use cases
more suitable for chatbot versus actual
autopilot agents How do you determine
which task is best for AI agents versus
more traditional workflow automation as
well as list of common pitfalls that
many other people encounter including
myself when deploying production agents
and best practice of how other people
resolve that like what's the best
practice for you to build integration
into existing systems This helped bring
a lot of clarities and many mistakes I
personally experienced So if you're
planning to build agents I highly
recommend you go and have a read and
this is totally free I have put a link
in the description below for you to
download Now let's talk about my new AI
coding workflow with task management
systems Firstly let's talk about ru
code's boomer task feature And if you
don't know ru code ro code you can
almost consider as a open-source cursor
that live inside visual studio code It
is totally free to use All you need to
do is just provide your own entropy key
and then it will just work like any
other AI coding agent that you've been
using But what's really cool about real
code is that unlike cursor where you
only have a few predefined agent mode Ro
allow you to create your own modes like
at default they will provide coding
agent architect agent that will help you
do the planning debug agent that help
you figure out where the arrow is But
you can also build custom modes like
boomer wrench mode where it will be
focusing on planning and breaking down
the plan into smaller manageable pieces
Think of it like delegating your work to
specialized assistant Each subtask runs
Boomrange tasks
in its own context So I can choose a
boomer range mode that I just customized
and then say help me build a to-do app
At top you can see that it will keep
track about how many token consumption
is as well as total amount of API cost
and it will firstly delegate a planning
task to the architect agent and this
architect agent will have this system
prompt where it will continuously
confirm with me about the requirements
and then it will start planning out the
project breaking down into specific
feature figure out things like user
story key feature components project
structure state management and many more
So it has a full understanding about all
dependencies between different functions
I can give feedback in the middle and
once the plan is finished and breaking
down to small tasks it can switch to the
code mode to start generating the code
and the code agent will start executing
different tasks based on the plan and
then complete the actual application for
me And you can see the result here is
very high quality and it even have
functionality built in where the agent
will be able to run the application in
the browser see the result to automate
testing as well And with this one the
result already feels better than what I
got out of box from cursor But on the
other hand cloud taskmaster integrate
much more deeply into cursor and wings
surfer First let's install the
taskmaster AI You can open terminal in
any folder and do npm install-g
taskmaster-ai And once it's finished you
can run a few different commands One
will be taskmaster in it This will set
up the project inside the folder So you
can just do taskmaster in it directly
But I would suggest you set up the
project first Like if you're building a
nextjs project with chessen you can just
do this command And once it's done we
can do cursor my app Inside here we can
do taskmaster in it This will ask for
the pent name and I'll just call it my
app Description doesn't really matter
You can skip all those stuff and then
just let it set things up And what will
happen now is that on the left side you
firstly see it add a few cursor rule
Some of them are generic one like this
cursor rule basically teach cursor how
can it add new cursor rules So as you go
deep into the implementation you can ask
it to reflect and creating rules about
the mistake it make for example and it
Claude Task master
will follow this rules to create the
next cursor rules and this self-improve
is basically the same thing it kind of
try to get cursor to do this proactively
and the step workflow is where it teach
cursor about all the commands it will
need to actually check all the task in
the backlog and if you're using
windserve there will be windserve root
here as well inside the scripts folder
it provide a structure about what does a
prd can look like but the most important
one is that it will have thisv.exam
example file What you need to do is swap
out this entropic key as well as
proplasticity key here So entropy is a
model that will be used to break down
your PRD into small tasks and they also
use perlastity to do some research So if
part of task is using a new package that
just released then it will actually use
perlasty to fetch the latest developer
documents and include those into the
task information So I recommend you add
both API key here and once you did that
we can start creating our PRD There are
many different ways you can create PRDs
If you're in the AI builder climate
building already you will have access to
tools like tanks coder the dev where it
will help you generate PRD automatically
and fill in all the gaps for the
features that you might not think of So
if you're already in the AI build club
you can use this tool to get the PRD
here But if you don't have access you
can also just chat with cursor agent use
that to help you generate PRD For
example I can just say help me build an
online game like Scribble but instead of
a human guess word it will be large
model guess a word So each round all
users will be given a same word and they
have 60 seconds to draw the image In the
end all images will be sent to open 4
and let it choose which image is closest
to the word Now play the role as the
engineer manager help me think through
what are the core features of
implementing such game and then it will
spit out the core functionalities
Obviously I can chat back and forth but
once I finish I can just say great now
let's help me build the core MVP
features requirements into prd.txe using
the example uh prd.txe tx as reference
which is what we have uh showing here
and then you will see a prd has been
created with good amount details and I
will accept that So now since we have
this prd generated the next step we can
use this command taskmaster parse drd to
breaking down this prd into small task
and this is where the power of
taskmaster begin So I will do this
taskmaster parse prd
scripts/prd.txt Okay so I had this arrow
uh just need making sure you remove this
example and let's do it again So now it
will start creating task files based on
this prd and you will see here where we
have task folder It has all the tasks
that created from taskmaster What we can
do is we can do taskmaster list and this
will show you the list of tasks that it
has been created What's really cool
about taskmaster task list is on the
right side you can see here's a
dependencies column So when breaking
down tasks it will actually list out the
task in a logical order and making sure
there are clear dependencies mapped out
So when it implement it can implement in
the right order Meanwhile there are also
some pretty useful commands You have
this command called analyze complexity
What this will do is that I can do task
master and analyze complexity This was
basically send all the task I created to
cloud 3.7 as well as perplexity
Basically ask it to just evaluate how
complicated or how difficult it is to
implement this feature And once it is
done I can do taskmaster complexity
report It will show me the evaluation of
each task and its complexity score But
what's really useful is for those
complex tasks it also give you the
prompt that you can copy At the moment
you can't really copy this directly If
the UI just break up but you can just
copy the first one and go to complexity
report and find the specific ID which is
this one and we can copy the expansion
prompt So here it generate a prompt
detailed technical implementation of
HTML 5 canva component including drawing
tools input handling across all devices
So I can just do this and now it
breaking down that specific task into
smaller ones And as we know once a
complex task breaking down to smaller
one it is more likely to succeed without
any error And you can continue doing
that um by adding another one for the
task number five So you get the drill Um
basically you can do this process back
and forth for a few times until you're
happy with the backlog here You can also
do things like update as well So if
later down the row you decide to like
change the plan you can also do
taskmaster update ID equal to like four
and prompt equal to something like make
sure we use three js And what will
happen is that once you give this prompt
it will actually update the whole plan
based on this new instruction which is
really really helpful But once it's done
you can do taskmaster list with subtasks
This will show all subtask here directly
So it will make it easier for you to
review all the task here So that's
pretty much it Once we done this you can
just go to the cursor agent and say
let's start implementing the app based
on task we created using taskmaster
Let's check the next most important task
first So you might have this arrow here
that it is reusing the wrong command Uh
so I will just tell it do not use script
dev.js use taskmaster instead Just go
list all task created and follow the
plan Then it will see the plan and
decide to implement the first one first
And as it work on the task it will also
set the status of this task to be in
progress And here since I actually turn
on the yolo mode of cursor which means
it didn't ask me for permission for
running any command lines I can
basically just go drink a coffee and let
it do the work And as it complete it
will mark this task as done and move on
to the next one by doing taskmaster next
But now when you're in Euro mode uh I
think cursor it will limit to 25
coursees if you're using the cloud 3.7
but you can actually put on Gemini 2.5
Pro Max This will allow you to skip this
limit and just do like 2002 coursees
without any pause here All right So it's
actually pretty crazy It just continue
executing tasks one up another and
generate a whole bunch of files probably
a few thousand lines of code And let's
just run that first Um so I'll do mpm
run def All right So if I try to open
this it has a lobby building and
authentication building So I can give a
name choose avatar start playing and my
user has been created I can set how much
time we have for drawing the difficulty
and whether it's public game or not So
it's pretty good Uh I can create but
okay looks like the actual game inside
hasn't been done yet but it's pretty
impressive about how much it is able to
deliver in just one go And I can come
back to do task master list with
subtasks So you can see that it done the
uh first four tasks but it haven't fully
finished the development game run logic
into my UI component Maybe that's why
the actual game room is not showing up
So I can ask it continue to implement
but you saw that I had this arrow here
and then I can prompt it now refract the
errors you made and creating new cursor
rules to making sure you don't make
those mistakes again Now you can see
that it actually adding new cursor rules
about nextjs app router Uh though for
some reason it didn't actually create
content which is bit weird and accept
this one So for now I just copy paste
manually I probably to update cursor
rules to making sure it will be saved
properly But now I'm going to continue
task Now let's check what is the next
task to complete to a point where we can
do some quick testing of the drawing
Okay after another 15 minutes of it just
doing the task by itself I got this game
that's kind of fully functional where I
can give it a name choose my avatar
start playing and also create a room
called Jason's room I can set a timer
about how long people can draw as well
as number of runs the difficulties and
if I create a room other people will be
able to see the room I created as well
Click on join We will see multiple
players in the room And if I start this
I will have this canva where people can
start drawing to describe what this uh
word is And on the top right corner
there's also a timer document how much
time is left And once it finish it will
send both result to chat GPT and GPT
will look at the image and give the
description and evaluation pick up the
winner to get points and then move on to
the next one So it's pretty amazing that
it did a whole multiplayers games like
this by itself in 20 minutes So this how
much performance gain you can get by
equip cursor with the right task
management systems and what's really
exciting is that this is just beginning
I can imagine those tools and system
became way better in a few months time I
also interviewed the creator of
taskmaster project where he gave more
detailed breakdown about the best
practice workflow to fully unleash the
power of taskmaster and exciting things
that they are working on right now If
you're interested you can join the AI
builder club where I put a full
interview and workflow inside the
community for you to check out as well
as bunch other learnings and tips from
industry experts for both vibe coding
and building production ready AI agents
And you will also have access to tools
like 10x coderdev where it will help you
generate bulletproof cursor PRD as well
as next.js boplay that already have all
payment backend database set up so you
can launch your SAS in just a weekend I
post a link in the description below for
you to join if you're interested I hope
you enjoyed this video I continue
sharing new tips and workflows I learned

What We Will Cover
if you have tried vibe coding with
cursor what you see on the screen
probably looks very familiar you ask it
to make a small change and suddenly your
entire project breaks the thing is that
cursor rewrites random parts of your
code loses track of the dependencies or
just spits out logic that doesn't make
any sense and the thing is that it's
just not with cursor this happens with
most AI coding agents once the context
of the project gets too big but this
doesn't have to happen because I found
this one approach that has made a
massive difference to the way I build
with AI coding agents and it's what I
call task coding and it just works by
giving your AI coding agent a proper
task management system that it can
follow and in this way cursor knows the
bigger picture but also understands what
to do step by step clearly and it never
overloads its context and I used this
exact method to build a fully working
multi-page app with charts and
authentication with barely no errors at
all and with a few shots so I barely
prompted it and it generated this entire
app for me and so in this video I will
show you exactly how I set up this task
management system how I structure my
prompts and my workflow to get clean
reliable results with cursor the thing
Current Methods
is that this process is nothing new
people have been doing it for a while in
cursor and other AI coding editors so
how this works is you create a PRD or
process requirement document and then
what you would do is ask cursor to break
that down into smaller tasks and then
put those into some markdown file as you
see over here and then as you keep
completing tasks or functionalities then
you would ask cursor to for example
takeick off line 11 or 12 and the thing
is that this process already works
really well when it comes to just
organizing your setup a bit more but now
Introducing the New Method
we have the ability to integrate more
sophisticated task management systems
such as cloud task master over here that
are able to integrate directly within
your command line interface or terminal
and they provide much larger level of
control over the tasks as you can see
here you can measure the tasks progress
you can measure which ones are high
priority and not and it tells you what
task to work on next as well it has
access to MCPs so you can give the
cursor agents the ability to write or
remove tasks or even edit tasks by
themselves and the way this works in a
nutshell is by you creating a PRD text
file with the cursor agent by chatting
back and forth to understand what you
want and once that's created then you
can run the command parse prd within
taskmaster and it will create you a
table with all the main tasks that
cursor needs to work on so the main
columns are the status and their
priority column which I think are
important to complete the tasks but then
you have these other two columns which I
think are so useful and I haven't seen
in any other tool or system that manages
tasks and the first one is the ability
to understand dependencies between tasks
and this is going to allow you to
minimize errors massively because it's
going to understand whenever doing a
task okay well I actually need this
first task completed before doing this
other one and I think that's that's a
massive upgrade and then you have the
complexity column as well which is going
to use a specialized model that is going
to access the internet grab any live
right up todate libraries or packages
bring that back in order to understand
how complex that task is so I think
these two columns are are very very
helpful and I got to minimize errors so
much so yeah I will be covering all of
What Will be Covered
this in a second i will show you how to
set up taskmaster and also all the best
practices that I discovered along the
way whilst building this project so
let's get started straight away right so
the first thing you should do is open a
new project within cursor and we are
going to open the command line interface
to install Taskmaster
Installing Task Master
globally so you can be in any folder it
doesn't matter because we're installing
it globally so mpn
install/g taskmaster AI so go ahead and
start
that let's install Taskmaster and once
done now we have the option of
initializing it globally as well but
before doing that I do recommend that
you start with the project structure so
if you want to start an XJS project with
chatn components then you would do npx
chat cn at latest initialize i love
chatnen because the components are very
sleek and clean so going to go ahead and
start chat okay to proceed yes all right
now we have set up the project structure
and now that's when you can now do the
other command which is taskmaster
initialize so we're going to grab that
paste it over here
and yeah so shell alliasis this allows
you to type TM instead of taskmaster for
any commands that taskmaster allows you
to run so I think these are some common
commands there you go you can list all
the tasks show the next task generate
task files and and a couple more but
we're going to put yes because I think
that's helpful yes let's
continue so we're enabling a new MCP
server Taskmaster AI perfect so I think
we have a couple choices for the models
we can use right so we got a couple I
mean all of them I think nearly are from
oper one as well but we're going to just
get going to keep it the same right for
now we're going to do sonar pro as well
so I see that we're getting two models i
think the first one is to yeah it says
for generation or updates so for
managing all the tasks and I think the
research model is for researching online
to research any update packages or
libraries that we need to add on the
project cuz I think the sonar pro is the
model from perplexity and these are
great at researching online compared to
the main models such as GPT or claude
right they're not they're not that good
at researching up-to-date stuff online
and that's why I'm pretty sure they used
Sonar Pro for the current one for the
you know for the predetermined one so
let's go ahead and and select that
fullback model okay so we're set up and
we have even a little task list to to
follow so that's great so if you notice
closely you would see that now we have a
few folders and files that got added
when we initialized taskmaster over here
so if you open this one you would see
that we have new rules if you haven't
seen these cursor rules before well this
is something that is recommended for you
to add before starting any project with
cursor and as the name suggests these
are rules that the cursor agent follows
in the development of your app so
there's a couple of them the first one
being the cursor rules and this is the
rule that we get cursor to make new
rules the second one that you see over
here gives the agent we're giving the
agent essentially all the commands that
it needs to check all of the tasks in
the background then I see on this one
it's similar to the first cursor rule
but essentially with this one it's
telling the cursor agent to create rules
proactively so it's just kind of
reinforcing the fact that you know it
should make rules for specific
circumstances all right and this last
cursor rule seems to be a more detailed
version of this one over here and I see
that it has emphasis as well on on MCP
tools and yeah I think it pretty much
covers all of the main commands that it
should run so that's that's pretty good
but yeah I think the essential one to
start given the instructions is to go to
this one over
here.f.example and I'm going to separate
these because these two seem to be the
important ones over here so this first
one is as we said for the first model to
manage the general uh task management
process and then perplexity for doing
the research on the internet right so
let me quickly stop and add my API keys
before I end up sharing my screen and
have you guys use $500 of my credits
okay one second all right so once you've
added your API keys make sure to change
the name of the example make sure to
just remove the example part because
then this environment file won't be
usable right so now that's set up we
have reached the fun part which is
chatting back and forth with cursor in
order to solidify the idea for your app
and once you understand how that's going
to work then you're going to ask cursor
to create a PRD for you if you don't
know what PRD stands for it stands for
project requirement document and this is
kind of the bible that the cursor agent
is going to follow in order to build the
app for you and I have talked already
about this in a video that I made before
about cursor and I really believe it's
important especially as a non-developer
for you to have this because if you
don't there's a high chance that you're
going to end up in some loophole or end
up producing spaghetti code that if you
then give to a developer it's going to
be really hard to untangle so you're
going to treat cursor especially the
cursor agent as a junior software
developer so whilst they're really good
at you know creating pieces of code and
developing apps for you they need to be
spoonfed so you need to tell them
exactly what they need to do at every
single step and that's what uh PRD helps
with all right so what we need to do now
is switch this to ask mode okay this is
the chat i think it was called chat
before but yeah we don't want it
actually making anything yet right you
Creating the Requirements
just want to ask figure out what we want
to do right so once you've had a back
and forth conversation with cursor to
understand what exactly you want to
build then we can switch this from ask
mode to agent mode over here so that it
can create a PRD for us right and we
will be using the example PRD text file
that got created when we initialized
taskmaster and one thing that I wanted
to make sure I guess this is optional
but I wanted it to understand what text
stack am I using for this project so
that it has a bit of context when
creating the the PRD so we will be
writing here the following and also make
sure to switch this to Gemini 2.5 Pro or
any of the models that have the max mode
Gemini 2.5 Pro as well because it has an
immense uh context window right so
here's the prompt great now build a
process requirements document prd with
the core MVP features into prd.txt so
I'm going to ask it to create a new text
file and it's going to use this file as
reference right the example PRD over
here all right don't forget to switch to
Gemini 2.5 Pro or any model that has a
large context window so that we can get
as as detail of a PRD as possible and
make sure to switch to agent mode as
well so that we can create that PRD file
and also you know use read the example
PRD file as well so we're going to go
ahead and execute that right so we see
the PRD here and I think it goes until
165 lines of code so I think that's
pretty good for an MVP hi there just
briefly want to stop the video to
announce that I have finally launched my
community Neuro Architects where I plan
to bring together their smartest people
in the space and business owners that
want to build the systems of the future
together using artificial intelligence
inside this community you'll find
everything ranging from all the
templates that I will make from the
YouTube videos as well as exclusive
community calls and also so much other
stuff so join right now stay tuned and
I'll see you inside okay so now that we
have the PRD we can go into the next
Parsing PRD
step which is parsing the PRD to
generate the main tasks and this is
where the magic of Taskmaster starts so
we're going to go ahead and add the
command over here in the CLI and let's
make sure we put in the right file so in
our case it's all in high caps prd.xt so
let's go ahead and run that now it's
going to grab that prdex file and
generate the main tasks for us right so
we see that it generated 10 new tasks
and we get the cost of the output and
all that so this is great now what we
can do is run taskmaster list in order
to see the tasks so this should show us
a table with the tasks so let's go ahead
and and view the tasks and it shows us a
couple things of the next task to work
and also this beautiful table over here
that contains well many things so the
title of the main task the status the
priority which makes a lot of sense and
this is honestly one of the best things
that you can add here so the
dependencies so when you are working
with an AI powered code editor such as
cursor or windsurf it can be really easy
to get stuck in a loop because you're
telling the the agent to do certain
things but you don't know in what order
does those tasks need to be done so it
could be that you're doing task number
three and before doing task number three
you should have done task number five or
task number one because you depend on
those tasks in some way right there's
some function or some piece of code that
is required on another place so having
these dependencies listed over here is
going to save you so much trouble and I
I really think this dependencies
property here is is very special and
it's going to allow you to just you know
develop with cursor at such high speeds
and also if you didn't realize on the
side on the task folder it has also
created these different text files each
containing well a lot of things right so
the task ID the details and so on and
then at the end you can see this
tasks.json JSON file which I'm pretty
sure it's going the cursor agent can use
to dynamically change any of the tasks
or any details if it needs to and
perhaps create new text files if it
needs to as well and there's also this
other really useful feature called
Analyze Complexity
analyze complexity so if I type in
taskmaster analyze complexity so this is
going to allow us to use remember at the
start that we had I asked you to put the
API keys for two models right so you had
the first model which was claude and
this one is going to manage the overall
tasks and and whatnot and then you had
the second model which was the
perplexity model and this perplexity
model you know we were like well you
know what is this going to be used for
well this is one of the places it's
going to be useful because it's going to
go it's going to use claude but also
this perplexity model to go online and
verify or understand how hard it is to
implement certain features so if you
press enter over here it's going to go
ahead and analyze the complexity of
those tasks so it's going to use claw
3.7 which is the one that we chose and
also sonar pro so it's going to going to
go online and in real time search how
feasible or how hard these tasks are to
implement which is really really
powerful stuff and once this is complete
we can then run
taskmaster can even just copy from here
because it's suggesting us to do that so
we can run that and it's going to give
us a complexity report right it's going
to give us a split of all the tasks how
complex they are and you can understand
how powerful this is as well and
something that is even more useful is
Breaking Down into Subtasks
these expansion commands that we have
here so if any of the tasks are really
complex to do we can use these commands
put them on the command line interface
and what's going to happen is that it's
going to break this big task into
smaller subtasks and you understand that
if you do this well the tasks become
more manageable so in order to do that
you can't do it directly they probably
should should fix it but I'm I'm pretty
sure they're on that but you can just go
on the JSON file that they made go to
that task so if we go to task ID number
three and we can just copy this over
here so expansion prompt right so you
can copy that and then go down here
paste it right all right so I copied the
first part which allows me to and then
for this I'll use this so right here
just copy all that and then go down here
paste that over there and now if you
press enter it's going to go ahead and
generate those five subtasks for the
hardest task and yeah right and once you
have generated those subtasks if they
don't appear here for some reason you
can go ahead and check taskmaster list
with subtasks and you can see here the t
the subtasks that I have added so I have
added one for ID3 and while I was off
camera I added another one for task ID
number six right so this is this is
really good right so you can keep doing
this over and over again until you're
happy with the amount of tasks that they
are you can keep making subtasks but the
main thing is that you understand that
the more you can break it down into
simpler tasks the less errors you're
going to have the cursor agents or
whatever agents that you use because
you're just breaking a bigger task into
more manageable chunks so that's the
whole idea with this and it's brilliant
and let's say also that you want to
change a specific task right let's say
the project has changed for some reason
now you require another package or
another off provider let's say instead
of superbase you want to use clerk what
you can do is go and type taskmaster
update and then you can put the ID of
the task so ID let's say um I don't
remember what uh the O was so the O flow
was I think it was at the start right
the user O system so id equals two and
then you can type in well the prompt
right you want to change the prompt so
you can go ahead and do this and then
put please change from superbase off to
clerk off right and what this is going
to do is create all of these tasks again
with a subtasks in order to accommodate
this change so this is really powerful
as well but yeah that's pretty much it
for this part if you want to go ahead
and check the tasks again you can run
that same command that I showed you
before right uh run list task tasks with
subtasks and then you can go again and
and and check you know if the structure
of of the ids are are correct or you
want any more granularity you know you
want to be more specific with some of
the tasks but once you reach this point
you are pretty much ready to start
getting started with building with the
cursor agent also something that I
forgot to tell you guys is that you can
run the expansion of the of the tasks
right expanding a a task into more
subtasks you might not need to copy the
prompt over here inside the task the
report on JSON I think it does it
automatically so if you just mentioned
the ID it would do this it would do this
automatically just just to just to add
that over there yeah because it
generated the the subtask for seven but
yeah I think I think if you just
mentioned the ID it would grab the
prompt from there but you could copy the
prompt as well and add stuff onto it if
you want i think that's how it would
work right so now we can get started and
Build
we can just say let's let's start
implementing the app features one by one
based on the tasks we have created that
have been created using taskmaster let's
go ahead onto the incoming task to build
something like
that right and you can see uh it's
running in yolo mode it's not asking me
for any command you know for any command
executions it's just auto running it so
this is this is great and yeah you can
just go since it's in yolo mode as I
explained before how to set it up right
you go on settings and and put the auto
run mode it was before called YOLO mode
now it's called auto run you can just go
take a little coffee break and and just
come back and there might be an error
that you might encounter if you use
another model if you use a model with
less uh with less context window which
is let's see if I can bring it up yeah
so this was the error that well it's not
an error it's a it's kind of a warning
message and this happens if you have you
choose an agent within the cursor agent
thing uh you choose a model that has a
lower context window it's going to stop
the agent after certain tool calls
because you just doesn't have enough
context to keep running so so yeah just
just uh if you if you see this message
make sure to switch onto something like
Gemini 2.5 or let's see what we have
yeah or any other model like 03 or
something like that i do recommend
Gemini i think Gemini is great right so
I I'm refining a few things and you see
also that it it calls the update task
which is really really powerful as well
so it calls these MCP tools in order to
update and change any tasks from the
task list which is very powerful i don't
have to manually go and change the
status of any other tasks it does it
automatically with these MC3 tools which
is very powerful it means that I can
just sit down relax for a bit and just
watch it go in a very structured manner
so yeah it's really impressive all right
so I'm back from my coffee break and I
let it do its thing seems like it wrote
more than a thousand lines of code and
yeah before leaving I did set up some
new tasks regarding the UI because what
I usually do is that I go to lovable or
bolt and I prepare the entire UI with
all the pages and whatnot and then I
come to cursor I bring the project to
cursor in order to finish the back end
and I feel that gives me uh maximum
control because what happens with bolt
or uh lovable is that they restrain you
within a specific stack or they make you
use superbase edge functions which for
some cases it might not be the best
thing so yeah I pass it here to have
full control if you want a video to
understand how my entire process is just
let me know down in the comments but
yeah so what I did is that I defined
this task over here core application UI
scaffolding and and yeah I created the
subtask as well and yeah it just allows
me to you know work pay by page and then
I also gave it another one for the
analytics page as well and yeah so and
then I gave it the order in which it
should do things so I told it please do
so I you know I popped this up and then
I said okay based on the tasks that you
have listed please do task number one
task number two and then jump straight
away into task number 11 and 13 and you
know I let it be and it did these three
tasks by itself and then I let it do
this last one as well and the thing is
that I did not check the the front end
at any point you know so I'm going to
we're going to check it right now so
let's go here let's do CD app and let's
do npm rundev let's go to localhost
let's see what curs made all right so it
did a pretty nice landing page given
that I well I didn't give it any
anything regarding the landing page so I
guess that's great it all it got all of
this from from the uh from the PD I
suppose so if I hit get started now okay
okay so if I hit the get started now
button it takes me to the sign-in page
i'm going to sign up in this case
continue with Google it also had a clerk
in development mode which is a good
thumbs up okay so now I'm in the
dashboard this seems to be the dashboard
and it has a hover on the card which is
amazing i told it to use chats and
components as well and it did a pretty
good job oh this is great so I didn't
tell cursor to go through the super base
and all that so this is all mock data
but still um this is pretty impressive
so you got the top performer so you can
track conversions from the YouTube
videos and whatnot if you go to the
YouTube page so we can manage YouTube
channels yes we can connect a new
channel this is great obviously the
functionalities don't work but that's
the point you know we work our way
through the UI we make sure all of the
pages and buttons all all show up
correctly and then you work on the on
the back end right so yes so the YouTube
works oh wow okay this is great drop-own
page destination URL I'm curious if it
generates us a um a link so let's have a
look if I put my YouTube
page see what it does all right so it
generated the link for us which is
pretty good and let's see if I can just
copy that if I copy that and I paste it
over here all right that works that's
pretty good i mean remember that this is
all mock data as well did a pretty good
job so we're in the links if you go to
analytics down here you can see that we
have another graph this is supposed to
be the detail analytics metrics right
pretty cool we can add a filter pretty
nice and then we have here the
performance data right pretty good
pretty good i mean remember that it did
all this within one shot as well so this
is pretty impressive i wonder like what
you can do with this like you can really
you can build really complex
applications with taskmaster now that
you have a bit more control with with
the ability to to you know go step by
step which is something that you know AI
code editors are not really good at and
yet so I've been messing with it a bit
now and if you see that it does an error
and you wanted to learn from that error
what you can do then you know for
example I had an error with the charts I
said I can't see the actual lines again
in the chart please learn what mistake
you have made and then add it as a
cursor rule so it's going to understand
what it did wrong and then it adds a
cursor rule so now in this case it's
going to keep learning and you know
accumulate and you know add all of these
errors as cursor rules so that when it
encounters something similar it can
refer to these cursor cursor rules so
that it ends up not doing these mistakes
again or at least that's the hope but
but yeah so keep adding these rules here
and it can keep learning and yeah it
should make less mistakes over time so
this is a pretty solid setup if you want
less errors within your your cursor
projects and I think I think yeah I
think this is amazing man so yeah I'll
leave the video there because I think
that's that's good enough for you to
understand how much you can do with
taskmaster and all other little tips
that I mentioned to you uh in just a few
shots right and it took me like took me
a few prompts to get to to this because
now the the agent has a structured way
in which we can follow the tasks and
this was not possible before right this
is this this changes the way we vibe
code and I don't know if to call it vibe
code anymore this is more of a
structured way of of vibe coding so yeah
if you want to learn more about this if
you want access to this code or whatnot
or any other guides let me know what you
want and I'll put it in the in the in
the community uh but yeah I think I'll
leave the video there so thanks for
watching if you enjoyed the video please
give it a thumbs up and and follow and
if you didn't like it let me know why in
the comments below and and yeah if you
if you have any suggestions for any
other videos in addition to what I
mentioned regarding getting preparing
the UI on on Bolt or Lovable and pushing
it then to cursor you want to see that
process if you're interested about that
let let me know in the comments below
i'll be happy to do that video cool all
right i'll see you guys in a bit thank
you bye

"

"Intro
i've been doing a lot of f coding recently and I'm completely convinced that AI is completely changing the game
for building apps or software in general actually and so in this video I want to walk you through how I plan and build an
app from scratch it's going to be a simple app a daily joke app and I'll show you some of the tools that I like
to use some best practices some of the pitfalls you want to avoid so you can use AI for your coding to its full
potential so let me quickly give you an overview of the tools that I like to use so I have a code editor called cursor
AI code editors (Cursor / VS Code + Copilot / Windsurf)
open here and that's what I will use in the video but there are other code editors out there as well that also have
AI features and that are also really good so I actually also like to use Visual Studio Code with GitHub Code
Pilot is a really good combination as well and Windsurf is actually also a very popular AI code editor tool now in
this video I will stick to Cursor there are some other tools as well that you will see mentioned very often so these are
AI prototyping (v0 / bolt.new / lovable)
V0 bolt and love bowl as well these are all really good to quickly try out some
idea you may have maybe do some prototyping or just quickly see if the idea that you have if that is feasible
let's say these tools are really good but I do find that at some point you need to jump out of them into an actual
code editor like cursor or visual studio code or win serve so I would say these are a good place to start and if you
have a reasonably simple app you can even create the entire app in one of these tools but for something that's a little bit more sophisticated I find
that I have to go to an actual code editor where I have maximum control so I typically don't use this as often as
some of these other tools if you have an idea maybe you want to draw it out first yourself you can use Figma for that they
make it easy to create a visual design of your app and then later you can implement that in cursor i like to use
Nex.js for my apps next is a so-called full stack framework so you have a front
Main web framework (Next.js)
end as well as a back end together in one app essentially it simplifies a lot of things but it is a little bit harder
Separate backend app (Encore)
to do certain things in Nex.js for example what if you want to have an API server that also services a mobile app
right next.js is a fullstack web framework so if you also want to service a mobile client let's say that's a
little bit harder to do also things like background jobs like a chron job basically I want to do something every
hour or so that's also a little bit harder to do in X.js also pub sub also if you want to have some kind of
microservices setup that's quite hard to do with Nex.js as well it's all one app it's all JavaScript or TypeScript so if
you want to use Go or some other technology that's going to be a problem so I've actually really enjoyed working
with Encore they are today's sponsor they make it very easy to create a backend application and in this video
I'll show you how to use that in conjunction with Nex.js so we'll have Nex.js as our main app and then we'll
have a separate backend created with Encore encore fits in really nicely in this AI stack actually they also have
these cursor rules that we can use makes it super fast to create highly sophisticated applications actually all
PRD (Product Requirements Document)
right so we want to build an app and it all starts with an idea so our idea is a an app and it just displays a joke and
it's a different joke every day hopefully we get some people coming back every day right just a simple app and I
want to build it as much as possible with AIS so what would that workflow look like so we could use one of those
tools to sketch it out or use like VZ to prototype something i often skip those
tools so so where would I start well some people talk about creating a
so-called product requirements document so basically a specification of how the
app should be structured you can do this in chat GPT some kind of chat model let me actually uh see what we get here now
in my view this is not absolutely necessary in many cases in the beginning of a project it's just an idea that you
have you don't know exactly what it should be yet it's probably still quite a vague idea so you don't know the exact
features it should have or the exact tools that it should use so actually um it may actually harm you to have a very
specific outline because you may be adding a bunch of things to your app that you're not going to need which may
slow you down actually so in my view this is not as important to getting started with an app in fact I think you
can skip this now if you have fleshed out your idea a lot you know exactly what it should be yes in that case it
can help out because because you can feed this into cursor's AI here and the
AI will be guided by the requirements that are specified here so it will do
almost exactly what you want right so this PRD is just going to be an overview of what the app is about the description
what are the goals of the app who should be using this app who are the primary users what are the key features right so
it already comes up with some ideas as well so actually it's nice to maybe quickly get some suggestions on your
idea some user stories so basically what are some practical things that a user
may want to do in the app all right so then the functional requirements are important here um because the AI is
going to create a bunch of code related to this right so you can see it already
adds a bunch of things yeah so here we have a lot of things actually now you could actually just copy this and now we
can go inside our AI code editor i'm using cursor for this video but the other ones work great as well and
currently my project is empty so I could open up this chat right i can open up this AI pane here and I can say scaffold
an app with this PRD and I could dump all of that in here if I would press
enter now it would create a lot of things that were all specified in the PRD now as I said I'm not the biggest
fan of this because in the beginning we don't know exactly yet we don't know exactly if we if we want to have push
notifications right so it's a bit of an overkill in the beginning in my view so where would I start well I want to use
Create Next.js app
Next.js actually that's where I would start i want to create a basic next.js boiler plate i can do it through the
chat so I could say something like create a Next.js app however I would actually like to do this manually myself
if I open up the terminal here new terminal I can do it myself here so I could say mpx create next app you can
look this up i can say the latest version and this would create a new next.js app folder and then put
everything in a new folder which is kind of annoying because I already have a folder i opened it in the code editor
already so I can add a period at the end so it will actually just directly put everything in this folder so let's
actually start there so I like to do it this way because uh this has basically zero margin of error i'm going to get
the exact next.js as starter that I want here very basic with no frills added
whereas I do find sometimes if you try to if you try to go with an AI agent it may sometimes add things that I don't
want or it may use a different version than I want it may use slightly different commands that I'm that I was
actually looking for and this is so important that I essentially want to have zero margin of error so I want to
use TypeScript yes yes yes yes app router yes turboac yes
no all right all right so now it's going to set up my NextJS app here all right so then I can close the terminal and now
from this point onwards I would mostly use the chat here to make changes to the
app because now I have the setup here this is uh this is exactly what I want so now I want to run the app i could
actually just say here in the chat run the app depending on which code editor you use you may not have unlimited uh
requests so for simple requests you may actually want to do it yourself so I do maybe want to open up terminal again let
me close this one and I can say mpm rundev that's how you would start a
nextjs app right so mpm rundev okay so now my nextjs app is starting i can see
where it's running i can click on this one all right so here I have my nextjs app running i see the homepage here
which is this page over here you can see nextjs has some starter here the first thing I like to do is actually just
remove a bunch of things here and just clear this out because our
idea is a bit different because we have a different idea so from this point onwards I would use this chat with the
Agent mode
agent mode here a lot so for example here we would have still the boiler plan right the title of our app we would want
to change this perhaps now I could manually change it we could say something like change the metadata to be about a daily joke app right so cursor
as of recording has the following options here so they have agent mode so basically before you had to pick whether
you just wanted to ask a question and it would just give you an answer here in the chat window or if it should actually
edit some code over here now you actually have agent mode and it will decide automatically for you whether it
should edit code or just give you an answer basically and let me actually show you what it will do so if I send
here you will see that um it it's changing my code here in the code editor so it has decided to invoke a edit tool
here okay and then I can view the changes it made now typically I accept this very quickly so I will just accept
here updated update here in nextJS you will see that title here at the top of the tab right and also and also if it's
ranking on Google the description will be displayed there right so just quickly show you here in cursor so I can create
a new chat here to clear out that previous contact so that's agent mode now it's using AI under the hood right
so the way this works is that cursor will take your message that you wrote here it will take that message maybe it
AI models auto-select
adds some other things under the hood it may do something with that but ultimately it will send it to open AI or
anthropic right so open AAI offers these three models 01 GPT 40 which we can also
use inside their own app chat GPT i was actually using 01 in chat GPT and there's also anthropic uh with with
their cloth model right so these are all really good so these are at as of recording the some of the cutting edge
models cursor right now automatically selects the right model for us however we can also pick the model ourselves if
we want but you can see it's it's all auto selected and I've had great results for that so that's okay with me now I
Add image
can also add an image here so maybe if you have an error in your app let's say you can take a screenshot and then add
it here so you can uh maybe so then it's clear to cursor or the a or the underlying AI models what the issue is
and then here on top actually we have something that's really important which is the context so if I say something
Context
like uh change the metadata what we just did to a daily joke app to be relevant
for a daily joke app if I don't add any context it doesn't really know where or
what this is about right so it may actually start a search by itself but if you know where it should be edited it's
better to attach that file as the context here so I know in nextJS the metadata here is in layout so I would
add the layout file here so then the content of this file will also be potentially sent to the AI model under
the hood including the message you wrote here so then cursor can get the result and change the relevant part of this
file so you can see that cursor actually got it right in the first try now sometimes it will not be the exact
result that you want so for example if I say something like create a new react
component for a joke cart let's say if I do something like this let's see what we get i didn't attach any context i also
didn't specify um what kind of conventions to use so here it prompts me to run a command so it wants to create a
components folder which I didn't specify but that's actually fine with me yes so it will create a components folder to
put in all the components and here it now has created a component here let's see what we get um you can see it
Cursor rules (MDC-files)
already starts to use a different tool here called framer motion and so this is already pretty uh important decision
actually so this is not something you would lightly add and also it has created this file using uppercase for
the J and the C and actually what I would prefer is all lower case with a hyphen my kebab case I actually prefer
that convention prompt like this and you do not have any cursor rules you may get a bunch of things in the result that you
don't want or need so I in this case would really like not to have additional
tools suddenly being used and also I want to use a different convention for naming the files which actually turns
out to be what I want but you can imagine that in other cases where it creates new folders all of a sudden that
may not be what you want so we want to steer the AI in the right direction so I actually find that cursor rules are
really helpful with this so cursor has some information on the website about the rules we can have global rules for
all our projects so I can go to my settings here uh let me close this so here we have uh some general rules we
have our features here we have models we have So here we have rules now here they call it user rule my uh understanding is
that those are the global rules but here we have project rules so these are going to be specific to our daily joke app
project let's actually do that so add a new rule i can give it a name let's call it uh component names right component
file names actually so I will press enter here okay so I get a so-called MDC
file let me close this and it puts that in a new folder called cursor slash
rules and then we have a new file here with the following name so basically whatever I put here will also be sent to
the AI model so not just my prompt and the context the file that I add but also
a rule here so it knows the format for example to process the result so what I would want here is always use kebab case
for new component file right so very simple but just to demonstrate how this would work now this rule if I open up my
chat here and start a new chat so now when I say something like uh create create a new component a joke card so
let's actually remove the one that it already created for us so I will actually leave the components folder but
I will delete this uh component so we want to make sure that now when I run this it will have the kebab case but
also don't use additional third party tool right this is maybe a little bit
fake but just to demonstrate how this would work so now I want it to take this rule into consideration when we send off
a request like this now it allows us to specify when this should be added this is a small rule file so actually I think
it makes sense to always add this cuz it's not going to pollute the contact too much the context too much you may
also want to go for autoattached so in that case you have to specify for which files this is relevant or agent
requested so then you have to give it a description and then cursor can decide if it's relevant or manual so in that
case I have to manually add the context here just like you would add a file i actually find that this is a bit risky
because you often forget to add it so if you can I do like to add to always add it now if you have a massive file here
and you're always adding this I would be a little bit more hesitant to always add it but for a small file this should be
fine so now let's see what we get so now let's try that again create a new component for a joke card okay so it
should Okay so uh it's going to do its thing again all right so now we get a new component and you can see it's using
joke-cart the kebab case that I like to use for my file names and you can see it's not using frame motion here it has
not added any third party tools all of a sudden right so with these cursor rules we can guide we can steer the AI we can
guide the AI into the direction that we want there are some other things that I personally do not like i don't like to
have types like this react.fc it's a bit of an old school way of typing these react components and probably it has to
do with these AI models they are trained sometime in the past right so they have a cutoff day they may be trained a year
ago or half a year ago and so now we are working with these AI models and so when they have to type these props as it's
called they're going to use what was popular at that point in time however these days I would say it's more common
to have the types like this right so we I like to use joke card props i actually like to use a type instead of interface
and then I would do something like this i think this looks a bit cleaner but this is also personal preference to a certain degree and I could also add that
as a cursor rule all right so I could specify that maybe in a new file or have one big file for coding conventions or
Repo for Cursor rules
something like that do you have to come up with these cursor rules all by yourself and actually no there are some
people out there that have already created them for you and they have shared it online so there is a GitHub
repository here called awesome cursor rules and here under cursor there are actually some really nice ones so here
there is a file for clean code quality and also one specifically for next.js so
here for example they add the nextjs best practices and you can see one of the rules they add here is to use the
lower case with dashes for the well directories but they give an example here with the file name as well so this
is really nice because it also allows you to add the latest conventions and the latest best practices because again
those AI models they have a cut off date so if something becomes common you know half a year later they don't they don't
necessarily know about that so you can add it as a rule and the rules tend to work really well so I would just copy
this now I can go here and actually just add that actually I will just delete this one and I will actually just create
a new file here called nextjs.mdc and I'm just going to paste everything in here and for now I will
just always add it it's a bit of a longer file so it may pollute the context a little bit too much if I'm
sending a huge file with every request now it's not a huge file uh so I think it's still acceptable but it's something
to be aware of I think so these cursor rules I would say are definitely something to check out now even just
Folder structure
coding a little bit you can see that our folder structure right now is already a little bit messed up because we have
components a components folder here and then also a components folder inside the app directory here so actually one of
the downsides with these AI agents I find is that have a tendency to screw up
the folder structure a little bit so the folder structure would be something that you can specify in the rules i think
that's a good one now for for me I like to use the components folder outside the app directory in Nex.js i like to
separate it out and just keep the app directory just for routing purposes mostly so now we can finally continue
building out our app so let's say something like change the homepage to show a daily joke and make it look make
it look good now by default it will attach the file that I have opened here but in this case I may also want to add
the joke card component so I would click here and add the joke cards here now the
cursor rule should be automatically added right because we say always add it here as context if you have manual there
you would have to not forget to actually attach it here as a piece of context as well however we don't need to do that
here all right so let's see what it comes up with okay so by default it will give you its thought process all right
so then at some point it will come up with some suggestions it will go file by file so as it's changing the other files
you can already the files it finish so let's just accept this one i will review the next file okay i can also accept all
of them here over here that's typically what I do so you can see it has now added something else again another folder so you have to pay attention to
the folder structure because it's really um it's really easily adding new folders and files so I think this is okay it
looks good let's actually try it out here all right so here we have an interesting looking page now uh so it's
going to display so it has added a title and it has something called new joke every 24 hours and then here in the card
it has a joke y 6 okay in hexadimal Canada because 7 8 9 all right so now I
would actually like to have a new joke every time I refresh so for now let's actually for now we actually want a new
joke every time I refresh all right so here uh you can see it has removed that
and it has removed the cache essentially so now when I refresh here you can see every time here I'm getting a new joke
here right so hopefully right so uh this is uh pretty cool okay and that's
basically how I would continue right right so you would continuously improve so let's quickly talk about some best practices that I find are really
Best practice #1
important to be aware of so the first one is actually to commit often basically as you just saw the AI is
pretty aggressive so to speak it's going to create a bunch of new folders very easily it very easily pulls in other
tools and so it may develop itself into a certain direction as you're prompting
if you're going down a certain direction and at some point you're like "Oh wait actually this is the wrong direction."
You want to go back right so you need to have a way to go back now in cursor actually one of the nice features is
that you can go up and you can actually click on restore checkpoint so it will uh that may help but actually a more
robust way is to use git so basically I can save my work right so right now if I like what I have or even if you don't
like what you have but you kind of want to have a point that you can go back to you can commit right so you can go here
and you have made a bunch of changes so um these changes need to be staged so I
can stage them all and so what did we do in this piece of work well we created a
well basically some scaffolding for our app right so we can call app scaffolding i'm going to commit here right so this
is now committed you can see I have uh two commits in my repo now right so if
you create a new nextJS app with that command by default it will already initialize a git repository as it's
called you don't need to completely master Git and now we have a second commit here with a piece of work we did
now this is still all on my own computer right so if I lose my computer right now or it gets stolen or it breaks down or
whatever I would lose all the work I did right so I also want to have a backup so not only do I want to go back I also
want to have a backup in case I lose my laptop let's say so I can go to GitHub and create a repository so here on
GitHub I can create a new repository i can call it Daily Joke app i will just
leave everything however I will make it private i will just keep everything the default all right so now I have this repository on GitHub basically a place
where I can push my code to so now if I go here um I want to publish this branch
now it doesn't know yet which place to publish this to so depending on whether you're already using GitHub or not you
may get some prompt here to authorize this with GitHub all right so after authorizing it already asks me where to
push this to so it's actually a private repo the repo already exists because we just created it ourselves so actually
with cursor we can sort of create it as we want to publish the brand now actually I already created it so in this
case I would like to use the one I already created so that that is a remote so I'm going to add a remote so then I
need to copy the URL of this remote that we just created so here I will go to remote add remote and just paste that
right here i can give it a name typically this is called origin and that should do it so now I can publish the
branch all right so now you can see when I go back to my repository here on GitHub you can see I have all my code
here now on GitHub right so this is a bit safer because now if I lose my laptop I still have a copy here in the
cloud but also if I make a mistake and I'm like oh the scaffolding wasn't good i can go back to the previous commit
right so uh that's basically a simple workflow for saving your work now I was manually setting up a GitHub repository
MCP-servers
i still had to do some manual things with GitHub there is a new sort of trend sort of new technology here called MCP
servers and there are some lists out there you can find them if you Google them you want to be careful with them
because this is all still very new and not really vetted properly yet so there there may be some security risk so the
idea of these uh MCP servers is that when you work with this AI agent it can
invoke those tools so by default of course if I say something like this code to uh my GitHub account cursor or these
underlying AI models they do not have access to my GitHub account right they cannot just access my GitHub account and
do all sorts of things the idea is is that you could set up perhaps a GitHub MCP server so then when you have a
prompt and cursor or the underlying AI models think that they have to use your
GitHub account they may try to use that MCP server so they can do something on your GitHub account and this is not just
with GitHub you can imagine that we have some other server for example that can take screenshots of our app maybe
Puppeteer some some of these automation uh tools they can automatically take screenshots so if you have uh if you
have a prompt let's say why is it not working cursor or the underlying AI models think hey we should invoke that
uh tool that can take screenshots so then we can get some additional context so we know what to do so it's basically
a way of allowing AI to invoke other tools it's really promising and it's definitely something to pay attention to
however as of recording this is still quite experimental and so I haven't used this as much yet it could be something
that becomes really big actually another best practice I want to show you is that I have a bunch of prompts here you get
Best practice #2
this in this chat window you get a bunch of history right so now I for example here I already had some prompts and have
some results and so this was all about that uh joke card and getting a daily
joke so now if I would ask something about uh change the TypeScript convey to
allow uh any type right this is something completely different but now because I have this in the same chat uh
history right in the same chat window here it may be that it's also going to send along all this information about
the daily joke fetching and this next revalidation along to the AI model even
though it has nothing to do with my task at hand so I would say a best practice is to actually simply create on the plus
button here click on the plus button here to create a new chat and just start from a clean slate here so now if I
would send this to the AI model it's not polluted with the history of the previous chat right these AI models can
get confused if you have a lot of other things that are not relevant so don't be afraid to simply start a new chat
whenever you have a new topic that you're going to start uh asking questions about so actually I want to
undo this i will simply reject here uh we don't want to allow that but all right so now we have a simple nextjs app
Encore for backend app - cron job, API, database
and whenever I refresh we get a new joke now what we actually want is to have a new joke every 24 hours so we want to
have let's say a background job a so-called chrome job that fetches a new joke every day and that is one thing
that is actually a little bit tricky to do in a plain next.js app so I actually want to start using Encore encore makes
it very easy for us to spin up a separate back-end application and it's not just for a chron job of course it
also is your API endpoint so Encore makes it really easy for us to spin up a separate backend app separate from our
main next.js app right so nextjs is a full stack framework so what we are doing is we are fetching data here on
the server side right this is a so-called async react component we're getting data it's going to render this
out and that's what will be sent to the client so nextjs is a fullstack framework but it does make things like a
chron job or let's say a rest api if you want to service a mobile client as well that's quite hard to do in a plain
next.js app also this is all javascript typescript what if you want to have some functionality be written in Go or some
other programming language or you want to have microservices because you want to have different people on your team work on different parts of the app
without affecting each other let's say well in that case you want to have a separate backend app so Encore makes that super easy and actually maybe
you've already used Express for example so that's what we will use here also makes it easy to set up a database and so on because what we want to do is we
want to fetch a joke here put it in a database and then when somebody goes here grab the joke from the database
again we could manually set up a data database with Postgress and Docker it's and you'll see Encore also makes it very easy for us to spin up a database as
well and other things as well but let me just show you how it works so this is a new tool and you may say "Oh now I have to learn all about this new tool." Well
Encore Cursor rules
not really we can keep sort of foding here we can keep chatting here because Encore has made it very easy for the AI
to implement these features so I have already installed Encore and here they actually give us some instructions that
we can use as cursor rules so actually I will open this up so here they actually provide us with one file that we can add
as a cursor rule so let me create a new file here and I will so let me create a new file here and I will call it ts i
will give it the same name instruction so this will basically tell the AI how encore works like how to set
up a new API endpoint and so on so we don't have to even learn much about it to get started with it if I leave it on
manual I have to make sure that whenever I have a question here I need to manually add it and actually I think a
lot of people forget it so just for demonstration purposes I'm going to always include it here so that is actually all we need to get started here
Frontend / Backend folder structure
so what we're going to do is this nextg app which is all of these files we're just going to use this as a front end so
we're just going to create a new folder here i will call that front end i do like to create my own folders this is
the one thing that I think these AIs aren't really good at yet which is to stick to a folder structure that makes
sense i find that they go off the rails quite a bit and you get some strange folder structures i will include all of
these files here all of the folders except the cursor rules i'm going to drop them into the front end folder okay
I will move everything update note modules yes and actually I may need to stop the server here next automatically
uh has created another folder here because it was still running I think so now I have my front end app in this folder now we could create a backend
folder manually like this but actually it's a little bit easier to do this with encore as well so what we can do now is
Encore app create
we can say encore app create and it will prompt us to use either Go or TypeScript so if you want to have a Go back end
that's possible as well however let's continue with TypeScript here they have some nice templates here out of the box for a backend application so if you want
to use some of these features and you want to have some scaffolding but we will start from scratch here all right so this will simply be our backend app
right so I'm just going to call this back end and now it has created a new folder here called back end and it will put all the files in there if I open
this up now you can see we have a new app here also with its own package.json and so on that will be a separate back
end that we're going to use for fetching jokes in the background we will put it in a database we'll have an API endpoint
and so on do I want to run the app right now okay let's do that so this is our separate back end and by default we can
inspect what's going on in the separate back back end app 9,400 it will show you
all the API endpoints you have so Encore will give you this dashboard out of the box here for us as developers to see
what's going on the end user would not see this our actual app that is accessible our API endpoints is going to
be on port 4,000 but on port 9,400 we can explore the API endpoints the
microservices that we have and so on i will close this for now this is our back end application i'm going to split the
terminal here so that we can also still run our nextj application i will actually switch it around so I will
still go into our front end and I will still do mpm rendev to run our nextj app so our nextj app right now when we uh
load the page let's take a look we are always fetching this still completely in our own next.js app let me actually
close all of this right we are just making a call to well get daily joke we put it in a separate function but this
would all be running in the nextjs app and we're just using some third party API here now let's actually try to make
it so that our next app is actually getting it from our separate backends application that will manage all of the
data so our encore app needs to have an API endpoint so that we can make this fetch call to encore so how do we create
API endpoint
an API endpoint in encore well let's try using AI and you I create a new chat
here i will create a new folder actually which we will call jokes just to structure everything's a little bit so
everything all the functionality related to jokes I want to put it in the jokes folder to get a random joke now I could
add some context here but it's actually not necessary because it has those cursor rules so it should know how to implement this let's actually just try
it right if we don't like it we can always reject it all right so it's going to learn a little bit about the folder structure here all right all right so
you can see it actually creates a new service right so in the world of microservices you can split up your
features by service so then if you have a very busy service getting a lot of requests we can scale that separately
other people in the team can develop in different services and then deploy separately and so on many benefits to
microservices now here I can already see it's actually starting to create a new database as well which we were going to
Database
use anyway so that's fine with me so let's see what it's going to come up with so it knows how to implement this because it's just taking a look at these
LLM instructions right so here there will be something about uh services right how to set up a service and it
will also say something about databases how to set up a database so by default it will actually use a SQL database a
Postgress database and this is looking really good and so I will just wait a little bit until it's finished all right so now it's finished and let's actually
just accept everything and see what it did for us so in this jokes.ts file this
is in our separate back end app it's actually create it has actually created a new database this is how it's done in
encore and again how does it know that well it's because that's described in here right so it already knows about
that now it has created a new API endpoint on this back end as well you can make a get call now we can specify a
more uh specific path as well so it needs to be a get call to let's say uh the path /random joke and we can also
specify whether it should be protected in encore so we can just use type safety we can just use intellisense here with
Typescript so we can see the option so expose basically means do we want to protect it with authentication or is it
okay that this endpoint is publicly accessible now what it will do is when you when you make a call to there it
will actually go into our database which we haven't even set up ourselves we didn't even need to do that encore will
provision resources for you automatically as well so it will just grab any of its random jokes in the database and then it will return that
joke by the way this surface now means everything in the jokes directory is going to belong to that particular
service right so this is all part of that service all right now when I use a database encore will use docker under
the hood so I do need to use docker here so let me actually if you haven't installed docker yet and you want to try
it out it's very easy you don't need to know much about it they have a docker desktop here on the website and I have
opened that up now so my docker is running now all right so now I want to restart the encore app i can actually
just say encore uh I actually can go into that backend folder and then I can say encore runs encore run all right so
it will actually create the database when we first run it now okay so if we invoke this API endpoint we should get a
Test API endpoint
joke now I will actually just comment this out just to try it out so if we have a joke uh haha this is a joke this
that's what we will return here how can we try this out well this is what we can try out in that dashboard that we get
right so port 9,400 this used to be quite tricky actually if you were creating an API
endpoint or you had to try it out and then test it all right so it has picked up now that our back end app has a joke
here i can try it out by just calling it i can see the result of this so it got back a response and it will actually
give us some trace information so we can see how long it took etc this is all in development here so this would be fast
of course because it's all on my computer you get a nice overview here of your services so we just have one jokes
service with one public API endpoint we can see the database here under infra we can see the connection between the
services right and visually so but of course we only have one service for now and and so this is a nice developer tool
here that we can use to see what's going on in our backend application so we have one API endpoint now and we have created
a database as well or Encore has created it for us and it does it with so-called SQL migration files automatically
created for us with the AI how does the AI know to do that because Encore already gave us these instructions right
so very very easy quick way to spin up separate back end it has actually seated the database uh jokes right so it has
already added some jokes in the database i actually don't have to hardcode and we can actually see if if it can grab it
from the database uh go back to our development dashboard here again and if I just try to call this API endpoint
again you can see we get a response here with one of those jokes that was already part of the database cool now that's a
separate app how do we get that into our NextJS application here in our front end well remember this API endpoint is just
Get data in Next.js from other backend app
running on localhost port 4000 so if we go there and we try to make a call to
well what is the path that we gave it well it's forward/random joke so forward/random joke we get our data
right here so we can technically just make an API call to this address a fetch call from our nextjs app right so what I
could do I could go here we can say uh here where we were fetching the joke right so we had a utility function for
that that we were then using in the server component we were using a third party API endpoint but now we want to use our own backend application i can
actually just copy that and let's paste that right here so here I'm just hard coding the URL for our API endpoint
encore also allows us to generate a client so we can interact with our API endpoints in a type manner uh for now I
will just keep this but uh it's good to know that that is also a possibility and it will actually need to be data book
that's how we are returning it actually we have the interface here so it has a setup and punch line so setup punch line
we will actually remove the category have the ID like this all right so this is what we are going to get let's try it
out now now if I refresh you can see we are getting those jokes that we actually have from our database let's actually
remove this so I will actually uh open up a new context here and this should just be the the
page.tsx this actually should be the joke card right so here sometimes you do need to find the file that is most
relevant so sometimes here you do need to find the right context here remove joke and actually I shouldn't remove
joke hashtag so that should be we actually also want to remove the category also remove category all right
so now we have this all right so now our nextjs front end app here is getting the data from our encore back end from our
database actually all managed by encore i didn't have to do a single thing to set up a database right so if I go to my
backend application here where we have the API setup I could also use this for a mobile app other websites or apps
separated from our NextJS app what we actually want to do is not just get a
Cron job (every 24 hours)
new joke whenever I refresh here i want to get a new joke every 24 hours so we want to have a so-called chron job and
again this would be quite hard to do in a mainjs app but let's try using encore here so we can just ask anor set up a
chron job so we actually so we actually fetch a new joke from a third party API
let's say from a third party every 24 hours and then only return that joke
from our API right so let's actually see what it can do here and again it will use the instructions with from the
encore rule all right so it's going to make a bunch of changes here let's All right so here let's take a look so we
still have we're still setting up our database and here it has created a function that will fetch a joke just
using some random source on the internet and let's take a look it will then insert it into our database okay now
that function needs to be run every 24 hours so here it's actually setting up a chron job with encore and again how does
it know that it's because that is all described in here right so it's doing it every 24 hours really nice developer
experience here if I I can change this of course if I want okay so now we have a chron job so when we go here within
that 24 hours we should always get the same joke for the whole day and then we hope that people come back to us every
day so we can simply say uh set up another API endpoint our front end can
get the joke of the day so it will actually get the most recent uh joke
right that's the solution it came up with actually quite uh makes sense um so it will just get the most recent joke
from the database um so here we can see it's it's going to order by created at descending okay so now we just need to
make an API call to joke of the day from our nextjs app so let's go to that
function where we run it we will just change the random joke to joke of the day and again I could create an API
client with encore as well if you're used to so if you've been using TRPC let's say there's something similar we
can do here all right so I do run into an error here and it says something it's actually has to do with the chron job
here so let's just what I like to do all right so when I run into an error like this I just copy the text here and I
will just dump it in here and actually it doesn't paste the actual text i find it's just the lines which actually I
don't really like but then I will just say something like bug and hopefully it can read this text here all right so I
will actually accept this let's accept everything here and try again all right so now when I go back to my app every time I refresh I'm just getting the
latest one from our database that will be changed every 24 hours because every 24 hours we are running this code where
it will fetch some joke from somewhere and it will store that in the database as well right now if I go back to my
backend dashboard here with Encore on port 9,400 you can see we actually have two
public API endpoints one private that's for the chron job this is really nice documentation actually so you can
quickly see what's going on in your app of course this is still a relatively simple app you can imagine if we have a
bunch of different services and API endpoints this is a very nice overview and also makes it very easy to quickly
try something so let's actually try invoking this fetch and store joke so this is what we would call every 24
hours would be quite hard to test if we we didn't use encore but with encore it's just a button click here i can call
the API we can even see the trace of it so basically how long it took some some
logging some logging here and now our database should be updated right so now if I go back here and if I refresh you
can see we have a new joke here which will be displayed until the next time that API endpoint is called which will
be 24 hours in our case but you can see I can very quickly uh try out my API endpoints here as well so you get
documentation and this testing of API endpoint as well as an overview of all your infrastructure um right here in the
dashboard i think that's a major plus as well so you can see how easy it is to build a full stack application i would
say pretty sophisticated here with a chron job with API endpoints that we can also use for other apps and so yeah I
think Encore fits in really nicely in this AI stack so I would say check out Encore you can find a link in the
description i had a great time using them by the way now that we have our app we want to deploy it we could deploy our
Deployment
NextGS app still to Forcell maybe you've already tried using that and you want to stick to Forcell for hosting and then we
need to host our back end application as well of course so this back end application needs to be hosted somewhere
as well now Encore offers you a cloud service as well so if you want to use that you can deploy this as well so they
have some instructions here we just have to we just have to use git but overall yeah I think AI has really changed the
game um one or two years ago we were actually just getting used to tabbing in your tech which was already a pretty
significant productivity boost but now I would say with these agents where you can chat and improve your app that way
actually this is the next level and it's just getting better so really exciting time we can build a lot of things now and so I hope this video helps you with
building apps with AI thanks to Encore for sponsoring the video thank you for watching and I will see you the next one"